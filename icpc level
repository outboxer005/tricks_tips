This section will cover:

Spragueâ€“Grundy (Game Theory advanced)

Matrix Exponentiation

Probability & Expected Value DP

Advanced Flow Modeling

Hopcroftâ€“Karp

FFT / NTT basics

Randomized algorithms

Advanced combinatorics

Moâ€™s algorithm

Sqrt decomposition

Rerooting DP

Centroid decomposition

Append this to your master README.

ðŸ”¥ SECTION 21 â€” ADVANCED GAME THEORY (SPRAGUEâ€“GRUNDY)
1ï¸âƒ£ Grundy Theory Core Idea

Every impartial game state has a Grundy number.

If:

XOR of all Grundy numbers = 0

â†’ Losing position
Else â†’ Winning position

2ï¸âƒ£ Mex Function

Minimum excluded number.

def mex(s):
    m = 0
    while m in s:
        m += 1
    return m
3ï¸âƒ£ Grundy Calculation Template
def grundy(n, moves, memo):
    if n == 0:
        return 0
    
    if n in memo:
        return memo[n]
    
    reachable = set()
    for move in moves:
        if n - move >= 0:
            reachable.add(grundy(n - move, moves, memo))
    
    memo[n] = mex(reachable)
    return memo[n]

Used in:

Stone games

Removing tokens

Splitting piles

ðŸ”¥ SECTION 22 â€” MATRIX EXPONENTIATION

Used when:

Recurrence relation

Fibonacci type

Linear recurrence

Transition DP

Matrix Multiply
def multiply(a, b, mod):
    n = len(a)
    result = [[0]*n for _ in range(n)]
    
    for i in range(n):
        for j in range(n):
            for k in range(n):
                result[i][j] += a[i][k] * b[k][j]
                result[i][j] %= mod
    return result
Fast Power
def matrix_power(mat, power, mod):
    n = len(mat)
    result = [[int(i==j) for j in range(n)] for i in range(n)]
    
    while power:
        if power & 1:
            result = multiply(result, mat, mod)
        mat = multiply(mat, mat, mod)
        power >>= 1
    
    return result

Complexity:

O(nÂ³ log k)
ðŸ”¥ SECTION 23 â€” PROBABILITY & EXPECTED VALUE DP

Key idea:
Expected value satisfies recurrence.

Example:
Expected steps until termination.

General pattern:

E[x] = sum(prob * E[next_state]) + cost

Solve by:

DP

Gaussian elimination (if cycles)

ðŸ”¥ SECTION 24 â€” HOPCROFTâ€“KARP (BIPARTITE MATCHING)

Used when:

Pairing two sets

Maximum matching

Complexity:

O(E âˆšV)

Skeleton:

from collections import deque

def hopcroft_karp(graph, n, m):
    pair_u = [-1]*n
    pair_v = [-1]*m
    dist = [0]*n

    def bfs():
        q = deque()
        for u in range(n):
            if pair_u[u] == -1:
                dist[u] = 0
                q.append(u)
            else:
                dist[u] = float('inf')
        found = False
        while q:
            u = q.popleft()
            for v in graph[u]:
                if pair_v[v] != -1 and dist[pair_v[v]] == float('inf'):
                    dist[pair_v[v]] = dist[u] + 1
                    q.append(pair_v[v])
                if pair_v[v] == -1:
                    found = True
        return found

    def dfs(u):
        for v in graph[u]:
            if pair_v[v] == -1 or (
                dist[pair_v[v]] == dist[u] + 1 and dfs(pair_v[v])
            ):
                pair_u[u] = v
                pair_v[v] = u
                return True
        dist[u] = float('inf')
        return False

    result = 0
    while bfs():
        for u in range(n):
            if pair_u[u] == -1 and dfs(u):
                result += 1
    return result
ðŸ”¥ SECTION 25 â€” FFT (FAST FOURIER TRANSFORM)

Used for:

Polynomial multiplication

Convolution

Count pair sums

Basic Python (using complex numbers):

import cmath

def fft(a):
    n = len(a)
    if n == 1:
        return a
    even = fft(a[0::2])
    odd = fft(a[1::2])
    t = [cmath.exp(-2j*cmath.pi*k/n)*odd[k] for k in range(n//2)]
    return [even[k]+t[k] for k in range(n//2)] + \
           [even[k]-t[k] for k in range(n//2)]

Complexity:

O(n log n)
ðŸ”¥ SECTION 26 â€” MO'S ALGORITHM

Used when:

Many offline range queries

Query answer mergeable

No updates

Complexity:

O((N + Q) âˆšN)

Template:

def mos_algorithm(arr, queries):
    block = int(len(arr)**0.5)
    queries.sort(key=lambda x: (x[0]//block, x[1]))
    
    curr_l = curr_r = 0
    curr_ans = 0
    
    for l, r in queries:
        while curr_r <= r:
            add(curr_r)
            curr_r += 1
        while curr_r > r+1:
            curr_r -= 1
            remove(curr_r)
        while curr_l < l:
            remove(curr_l)
            curr_l += 1
        while curr_l > l:
            curr_l -= 1
            add(curr_l)
ðŸ”¥ SECTION 27 â€” SQRT DECOMPOSITION

Split array into blocks.

Query:

O(âˆšN)
ðŸ”¥ SECTION 28 â€” REROOTING DP

Used in trees:

Compute answer for all nodes

Pattern:

Compute DP from root

Propagate answer to children

Used in:

Sum of distances

Tree DP problems

ðŸ”¥ SECTION 29 â€” CENTROID DECOMPOSITION

Used for:

Path counting in tree

Distance queries

Complexity:

O(N log N)

Core idea:
Recursively remove centroid.

ðŸ”¥ SECTION 30 â€” RANDOMIZED ALGORITHMS

Use when deterministic too slow.

Examples:

Random pivot quicksort

Millerâ€“Rabin primality test

Pollard Rho factorization

Random hashing to avoid collisions

ðŸ”¥ SECTION 31 â€” ADVANCED COMBINATORICS

Precompute factorial and inverse factorial.

MOD = 10**9+7
MAX = 10**6

fact = [1]*(MAX+1)
invfact = [1]*(MAX+1)

for i in range(1,MAX+1):
    fact[i] = fact[i-1]*i % MOD

def mod_pow(a,b):
    res=1
    while b:
        if b&1:
            res=res*a%MOD
        a=a*a%MOD
        b>>=1
    return res

invfact[MAX] = mod_pow(fact[MAX], MOD-2)

for i in reversed(range(MAX)):
    invfact[i] = invfact[i+1]*(i+1)%MOD

def nCr(n,r):
    if r<0 or r>n:
        return 0
    return fact[n]*invfact[r]%MOD*invfact[n-r]%MOD
ðŸ”¥ SECTION 32 â€” FINAL GRANDMASTER INSIGHT

At elite level:

You must master:

Modeling transformation

State compression

DP optimization

Graph transformation

Math modeling

Complexity estimation instinct

Edge-case paranoia

Constant factor optimization
