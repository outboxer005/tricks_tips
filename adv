Perfect.
Now we build a **serious Competitive Programming Master README**.

This will go much deeper:

* Modeling tricks
* Edge case handling
* Advanced graph tricks
* Advanced DP tricks
* Geometry modeling patterns
* Game tricks
* Implementation traps
* Time complexity strategy
* Optimization mindset
* Pattern recognition rules
* Contest survival guide

You can paste this into:

```
README_COMPETITIVE_PROGRAMMING_MASTER.md
```

---

# üß† Competitive Programming Master Handbook

This document contains deep competitive programming tricks, modeling techniques, patterns, and optimization strategies used in serious contests.

---

# üî• SECTION 1 ‚Äî PROBLEM MODELING TRICKS

---

## 1Ô∏è‚É£ Convert Everything to Graph

Many problems are secretly graph problems.

### If you see:

* Grid movement
* Teleportation
* Roads / connections
* Transformations between states
* Words transforming (like word ladder)

### Think:

Graph nodes = states
Edges = valid transitions

### Example: Grid ‚Üí Graph

```python
def node_id(i, j, m):
    return i * m + j
```

### Important:

* Weighted edges ‚Üí Dijkstra
* Unweighted ‚Üí BFS
* Negative edges ‚Üí Bellman-Ford

---

## 2Ô∏è‚É£ State Compression Trick

If state has multiple dimensions:

Example:

* Position + mask
* Position + last color
* Position + parity

Convert to tuple or encode to integer.

```python
state = (x, y, mask)
```

Or compress:

```python
state_id = x * M * (1<<k) + y * (1<<k) + mask
```

Used in:

* BFS with mask
* DP on states
* Game problems

---

# üî• SECTION 2 ‚Äî EDGE CASE STRATEGY

Most WA errors come from edge cases.

Always check:

* n = 1
* n = 0
* All values equal
* Strictly increasing
* Strictly decreasing
* Large values (10^9)
* Negative values
* Overflow possibility
* Graph with no edges
* Fully connected graph

---

# üî• SECTION 3 ‚Äî ADVANCED GRID TRICKS

---

## üîπ BFS Layering Trick

If you need distance layer by layer:

```python
from collections import deque

def bfs_levels(start):
    q = deque([start])
    dist = {start: 0}
    
    while q:
        node = q.popleft()
        for nei in graph[node]:
            if nei not in dist:
                dist[nei] = dist[node] + 1
                q.append(nei)
    return dist
```

---

## üîπ 0-1 BFS

When weights are only 0 or 1.

```python
from collections import deque

def zero_one_bfs(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    dq = deque([start])
    
    while dq:
        node = dq.popleft()
        for nei, w in graph[node]:
            if dist[node] + w < dist[nei]:
                dist[nei] = dist[node] + w
                if w == 0:
                    dq.appendleft(nei)
                else:
                    dq.append(nei)
    return dist
```

Faster than Dijkstra for small weights.

---

# üî• SECTION 4 ‚Äî DP PATTERN LIBRARY

---

## üîπ Subarray DP

Pattern:

```python
dp[i] = best answer ending at i
```

Example: Kadane

```python
def kadane(arr):
    max_sum = arr[0]
    curr = arr[0]
    
    for i in range(1, len(arr)):
        curr = max(arr[i], curr + arr[i])
        max_sum = max(max_sum, curr)
    
    return max_sum
```

---

## üîπ LIS O(n log n)

```python
import bisect

def lis(arr):
    temp = []
    for x in arr:
        idx = bisect.bisect_left(temp, x)
        if idx == len(temp):
            temp.append(x)
        else:
            temp[idx] = x
    return len(temp)
```

---

## üîπ Bitmask DP Template

Used when n ‚â§ 20.

```python
def tsp(dist):
    n = len(dist)
    dp = [[float('inf')] * n for _ in range(1<<n)]
    dp[1][0] = 0
    
    for mask in range(1<<n):
        for u in range(n):
            if mask & (1<<u):
                for v in range(n):
                    if not mask & (1<<v):
                        new_mask = mask | (1<<v)
                        dp[new_mask][v] = min(
                            dp[new_mask][v],
                            dp[mask][u] + dist[u][v]
                        )
    return min(dp[(1<<n)-1])
```

---

# üî• SECTION 5 ‚Äî ADVANCED GRAPH TRICKS

---

## üîπ Detect Cycle in Directed Graph

```python
def has_cycle(graph):
    visited = set()
    stack = set()
    
    def dfs(node):
        visited.add(node)
        stack.add(node)
        
        for nei in graph[node]:
            if nei not in visited:
                if dfs(nei):
                    return True
            elif nei in stack:
                return True
        
        stack.remove(node)
        return False
    
    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    
    return False
```

---

## üîπ Topological Sort

```python
from collections import deque

def topo_sort(graph):
    indegree = {u:0 for u in graph}
    for u in graph:
        for v in graph[u]:
            indegree[v] += 1
    
    q = deque([u for u in graph if indegree[u] == 0])
    order = []
    
    while q:
        node = q.popleft()
        order.append(node)
        for nei in graph[node]:
            indegree[nei] -= 1
            if indegree[nei] == 0:
                q.append(nei)
    
    return order
```

---

# üî• SECTION 6 ‚Äî GEOMETRY DEEP TRICKS

---

## üîπ Polygon Area (Shoelace Formula)

```python
def polygon_area(points):
    n = len(points)
    area = 0
    
    for i in range(n):
        x1, y1 = points[i]
        x2, y2 = points[(i+1)%n]
        area += x1*y2 - x2*y1
    
    return abs(area) / 2
```

---

## üîπ Convex Hull (Monotonic Chain)

```python
def convex_hull(points):
    points = sorted(points)
    
    def cross(o, a, b):
        return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])
    
    lower = []
    for p in points:
        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:
            lower.pop()
        lower.append(p)
    
    upper = []
    for p in reversed(points):
        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:
            upper.pop()
        upper.append(p)
    
    return lower[:-1] + upper[:-1]
```

---

# üî• SECTION 7 ‚Äî GAME THEORY TRICKS

---

## üîπ Nim Game

If XOR of all piles = 0 ‚Üí losing position.

```python
def nim(piles):
    xor_sum = 0
    for pile in piles:
        xor_sum ^= pile
    return xor_sum != 0
```

---

# üî• SECTION 8 ‚Äî OPTIMIZATION STRATEGY

---

## If constraints are:

| n        | Approach    |
| -------- | ----------- |
| n ‚â§ 10   | brute force |
| n ‚â§ 20   | bitmask     |
| n ‚â§ 10^3 | O(n¬≤)       |
| n ‚â§ 10^5 | O(n log n)  |
| n ‚â§ 10^6 | O(n)        |

---

## Speed Tricks

* Use local variables inside loops
* Avoid repeated list slicing
* Use sys.stdin
* Use iterative instead of recursion if deep
* Use PyPy sometimes for heavy loops
* Pre-allocate arrays

---

# üî• SECTION 9 ‚Äî HARD CONTEST SURVIVAL RULES

1. Read constraints first.
2. Identify type:

   * Graph?
   * DP?
   * Math?
   * Greedy?
3. Solve easy subtasks.
4. Test on edge cases.
5. Don‚Äôt panic.
6. If stuck 20 mins ‚Üí switch problem.
7. Come back with fresh mind.

---

# üî• SECTION 10 ‚Äî COMMON TRAP LIST

* Off by one
* Integer overflow
* Using float when int required
* Forgetting modulo
* Using recursion without limit
* Mutating list during iteration
* Sorting inside loop
* Using list in membership check instead of set

---

# üöÄ FINAL NOTE

Competitive programming is not about memorizing code.

It is about:

* Pattern recognition
* State modeling
* Edge case handling
* Optimization instinct

---

Next we can go into:

* Extreme DP patterns
* Advanced data structures (Segment Tree lazy, persistent)
* Advanced flow (Dinic)
* String algorithms deep
* Advanced game theory
* Hard geometry (line intersection, rotating calipers)
* Interactive problems

Tell me which deep domain next.
We build your repository like a grandmaster. üî•
