Perfect âœ…
Below is a **clean README.md formatted version** of the Competitive Coding Tricks you asked for.
You can directly copy-paste this into:

```
README_COMPETITIVE_TRICKS.md
```

---

# ðŸ§  Competitive Coding Tricks Handbook

This file contains **important tricks, templates, and modeling patterns** frequently used in competitive programming.

Use this as a quick-reference during contests.

---

# ðŸŽ² 1. Dice Simulation Tricks

### ðŸ”¹ Dice Representation

Store dice faces as:

```
        top
left  front  right  back
        bottom
```

Represent as:

```python
# [top, bottom, left, right, front, back]
dice = [1, 6, 4, 3, 2, 5]
```

---

### ðŸ”¹ Roll Operations

```python
def roll_north(d):
    return [d[4], d[5], d[2], d[3], d[1], d[0]]

def roll_south(d):
    return [d[5], d[4], d[2], d[3], d[0], d[1]]

def roll_east(d):
    return [d[2], d[3], d[1], d[0], d[4], d[5]]

def roll_west(d):
    return [d[3], d[2], d[0], d[1], d[4], d[5]]
```

### ðŸ“Œ Use Cases

* Dice rolling problems
* 3D state simulation
* Cube orientation tracking

---

# ðŸ§­ 2. Grid Movement Templates

### ðŸ”¹ 4 Directions

```python
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
```

---

### ðŸ”¹ 8 Directions

```python
dx = [-1,-1,-1,0,0,1,1,1]
dy = [-1,0,1,-1,1,-1,0,1]
```

---

### ðŸ”¹ Knight Moves

```python
dx = [-2,-2,-1,-1,1,1,2,2]
dy = [-1,1,-2,2,-2,2,-1,1]
```

### ðŸ“Œ Standard Usage

```python
for i in range(4):
    nx = x + dx[i]
    ny = y + dy[i]
```

---

# ðŸ—º 3. Coordinate Compression

Used when values are large (10^9) but count is small.

```python
def coordinate_compress(arr):
    unique = sorted(set(arr))
    mapping = {v:i for i,v in enumerate(unique)}
    return [mapping[x] for x in arr]
```

### ðŸ“Œ Use Cases

* Segment Trees
* Fenwick Trees
* Interval Problems
* Geometry

---

# âž• 4. Prefix Sum Tricks

### ðŸ”¹ 1D Prefix

```python
def prefix_sum(arr):
    n = len(arr)
    pre = [0]*(n+1)
    for i in range(n):
        pre[i+1] = pre[i] + arr[i]
    return pre
```

Range sum:

```
sum(l, r) = pre[r+1] - pre[l]
```

---

### ðŸ”¹ 2D Prefix

```python
def prefix_2d(grid):
    n = len(grid)
    m = len(grid[0])
    pre = [[0]*(m+1) for _ in range(n+1)]
    
    for i in range(n):
        for j in range(m):
            pre[i+1][j+1] = (
                grid[i][j]
                + pre[i][j+1]
                + pre[i+1][j]
                - pre[i][j]
            )
    return pre
```

---

# ðŸ”„ 5. Difference Array (Range Updates)

```python
def range_update(n, updates):
    arr = [0]*(n+1)
    
    for l, r, val in updates:
        arr[l] += val
        arr[r+1] -= val
    
    for i in range(1,n):
        arr[i] += arr[i-1]
    
    return arr[:-1]
```

### ðŸ“Œ Use Cases

* Many range updates
* Competitive constraints optimization

---

# ðŸ”¢ 6. Bit Manipulation Tricks

### ðŸ”¹ Power of 2

```python
def is_power_of_two(n):
    return n > 0 and (n & (n-1)) == 0
```

---

### ðŸ”¹ Count Set Bits

```python
def count_bits(n):
    return bin(n).count('1')
```

---

### ðŸ”¹ Rightmost Set Bit

```python
def rightmost_set_bit(n):
    return n & -n
```

---

### ðŸ”¹ Submask Iteration

```python
mask = 13
sub = mask
while sub:
    print(sub)
    sub = (sub-1) & mask
```

Used in bitmask DP.

---

# ðŸŒ 7. Graph Modeling Tricks

### ðŸ”¹ Grid to Graph Node ID

```python
def node_id(i, j, m):
    return i*m + j
```

---

### ðŸ”¹ Multi-Source BFS

```python
from collections import deque

def multi_source_bfs(graph, sources):
    dist = {node: float('inf') for node in graph}
    q = deque()
    
    for s in sources:
        dist[s] = 0
        q.append(s)
    
    while q:
        node = q.popleft()
        for nei in graph[node]:
            if dist[nei] > dist[node] + 1:
                dist[nei] = dist[node] + 1
                q.append(nei)
    
    return dist
```

---

# ðŸ“ 8. Geometry Tricks

### ðŸ”¹ Euclidean Distance

```python
import math

def distance(p1, p2):
    return math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)
```

---

### ðŸ”¹ Manhattan Distance

```python
def manhattan(p1, p2):
    return abs(p1[0]-p2[0]) + abs(p1[1]-p2[1])
```

---

### ðŸ”¹ Cross Product (Orientation Test)

```python
def cross(o, a, b):
    return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])
```

Result:

* > 0 â†’ Counterclockwise
* < 0 â†’ Clockwise
* = 0 â†’ Collinear

Used in:

* Convex Hull
* Line Intersection
* Polygon Area

---

# ðŸ“Š 9. Sweep Line Trick

```python
events = []

for l, r in intervals:
    events.append((l, 1))
    events.append((r+1, -1))

events.sort()

active = 0
for pos, val in events:
    active += val
    print(pos, active)
```

Used in interval overlap problems.

---

# ðŸ‘† 10. Two Pointers Template

```python
def two_pointers(arr):
    left = 0
    for right in range(len(arr)):
        while some_condition:
            left += 1
```

Used for:

* Longest subarray
* Sliding window
* At most K distinct

---

# ðŸ” 11. Binary Search on Answer

```python
def binary_search_answer(low, high):
    while low < high:
        mid = (low + high) // 2
        
        if possible(mid):
            high = mid
        else:
            low = mid + 1
    
    return low
```

Used when:

* Minimize maximum
* Maximize minimum
* Partitioning problems

---

# âš¡ 12. Meet in the Middle

```python
from itertools import combinations

def subset_sums(arr):
    n = len(arr)
    sums = []
    for r in range(n+1):
        for comb in combinations(arr, r):
            sums.append(sum(comb))
    return sums
```

Used when:

* n â‰¤ 40
* Subset sum problems

---

# ðŸš€ 13. Fast I/O

```python
import sys
input = sys.stdin.readline
```

---

# ðŸ§® 14. Modular Arithmetic

```python
MOD = 10**9 + 7

def mod_add(a, b):
    return (a + b) % MOD

def mod_mul(a, b):
    return (a * b) % MOD

def mod_pow(a, b):
    res = 1
    while b:
        if b & 1:
            res = (res * a) % MOD
        a = (a * a) % MOD
        b >>= 1
    return res
```

---

# ðŸ“Œ Pattern Recognition Guide

| If Problem Mentions      | Think About              |
| ------------------------ | ------------------------ |
| Shortest path            | BFS / Dijkstra           |
| Many range queries       | Prefix / Segment Tree    |
| Many range updates       | Difference Array         |
| Large values small count | Compression              |
| Minimize max             | Binary Search Answer     |
| Small n subsets          | Bitmask / Meet in Middle |
| Interval overlaps        | Sweep Line               |
| Tree queries             | LCA / Binary Lifting     |

---

This is your **Core Competitive Coding Tricks README**.

---

Next we can create:

* Advanced DP Tricks README
* Graph Advanced Tricks README
* Geometry Advanced Tricks README
* Game Theory Tricks README
* Hard Implementation Edge Cases README

Tell me the next section and we continue building your master repository ðŸš€
